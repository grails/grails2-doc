<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
        <title>12. Plug-ins</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
        <link rel="icon" href="../img/favicon.ico" type="image/x-icon"/>
        <link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon"/>
    </head>
    <body class="body">
        <div id="header">
            <h1><a name="12. Plug-ins">12. Plug-ins</a></h1>
        </div>
        <div id="toc">
            <div class="tocItem" style="margin-left:10px"><a href="#12.1 Creating and Installing Plug-ins">12.1 Creating and Installing Plug-ins</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.2 Plugin Repositories">12.2 Plugin Repositories</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.3 Understanding a Plug-ins Structure">12.3 Understanding a Plug-ins Structure</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.4 Providing Basic Artefacts">12.4 Providing Basic Artefacts</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.5 Evaluating Conventions">12.5 Evaluating Conventions</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.6 Hooking into Build Events">12.6 Hooking into Build Events</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.7 Hooking into Runtime Configuration">12.7 Hooking into Runtime Configuration</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.8 Adding Dynamic Methods at Runtime">12.8 Adding Dynamic Methods at Runtime</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.9 Participating in Auto Reload Events">12.9 Participating in Auto Reload Events</a></div><div class="tocItem" style="margin-left:10px"><a href="#12.10 Understanding Plug-in Load Order">12.10 Understanding Plug-in Load Order</a></div>
        </div>
        <div id="content">
            Grails is first and foremost a web application framework, but it is also a platform. By exposing a number of extension points that let you extend anything from the command line interface to the runtime configuration engine, Grails can be customised to suit almost any needs. To hook into this platform, all you need to do is create a plugin.<p class="paragraph"/>Extending the platform may sound complicated, but plugins can range from trivially simple to incredibly powerful. If you know how to build a Grails application, you'll know how to create a plugin for <a href="../guide/single.html#12.4 Providing Basic Artefacts" class="guide">sharing a data model</a> or some static resources.
<h2><a name="12.1 Creating and Installing Plug-ins">12.1 Creating and Installing Plug-ins</a></h2><h4>Creating Plugins</h4><p class="paragraph"/>Creating a Grails plugin is a simple matter of running the command:<p class="paragraph"/><div class="code"><pre>grails create&#45;plugin &#91;PLUGIN NAME&#93;</pre></div><p class="paragraph"/>This will create a plugin project for the name you specify. Say for example you run <code>grails create-plugin example</code>. This would create a new plugin project called <code>example</code>.<p class="paragraph"/>The structure of a Grails plugin is exactly the same as a regular Grails project's directory structure, except that in the root of the plugin directory you will find a plugin Groovy file called the "plugin descriptor".<p class="paragraph"/>Being a regular Grails project has a number of benefits in that you can immediately get going testing your plugin by running:<p class="paragraph"/><div class="code"><pre>grails run&#45;app</pre></div><p class="paragraph"/>The plugin descriptor itself ends with the convention <code>GrailsPlugin</code> and is found in the root of the plugin project. For example:<p class="paragraph"/><div class="code"><pre>class ExampleGrailsPlugin &#123;
   def version = 0.1<p class="paragraph"/>   &#8230;
&#125;</pre></div><p class="paragraph"/>All plugins must have this class in the root of their directory structure to be valid. The plugin class defines the version of the plugin and optionally various hooks into plugin extension points (covered shortly).<p class="paragraph"/>You can also provide additional information about your plugin using several special properties:
<ul class="star">
<li><code>title</code> - short one sentence description of your plugin</li>
<li><code>version</code> - The version of your problem. Valid versions are for example "0.1", "0.2-SNAPSHOT", "0.1.4" etc.</li>
<li><code>grailsVersion</code> - The version of version range of Grails that the plugin supports. eg. "1.1 &#62; *"</li>
<li><code>author</code> - plug-in author's name</li>
<li><code>authorEmail</code> - plug-in author's contact e-mail</li>
<li><code>description</code> - full multi-line description of plug-in's features</li>
<li><code>documentation</code> - URL where plug-in's documentation can be found</li>
</ul><p class="paragraph"/>Here is an example from <a href="http://grails.org/Quartz+plugin:" target="blank">Quartz Grails plugin</a><p class="paragraph"/><div class="code"><pre>class QuartzGrailsPlugin &#123;
    def version = <span class="java&#45;quote">"0.1"</span>
	def grailsVersion = <span class="java&#45;quote">"1.1 &#62; &#42;"</span>
    def author = <span class="java&#45;quote">"Sergey Nebolsin"</span>
    def authorEmail = <span class="java&#45;quote">"nebolsin@gmail.com"</span>
    def title = <span class="java&#45;quote">"This plugin adds Quartz job scheduling features to Grails application."</span>
    def description = '''
Quartz plugin allows your Grails application to schedule jobs to be
executed using a specified interval or cron expression. The underlying
system uses the Quartz Enterprise Job Scheduler configured via Spring,
but is made simpler by the coding by convention paradigm.
'''
    def documentation = <span class="java&#45;quote">"http://grails.org/Quartz+plugin"</span><p class="paragraph"/>   &#8230;
&#125;</pre></div><p class="paragraph"/><h4>Installing &#38; Distributing Plugins</h4><p class="paragraph"/>To distribute a plugin you need to navigate to its root directory in a terminal window and then type:<p class="paragraph"/><div class="code"><pre>grails <span class="java&#45;keyword">package</span>&#45;plugin</pre></div><p class="paragraph"/>This will create a zip file of the plugin starting with <code>grails-</code> then the plugin name and version. For example with the example plug-in created earlier this would be <code>grails-example-0.1.zip</code>. The <code>package-plugin</code> command will also generate <code>plugin.xml</code> file which contains machine-readable information about plugin's name, version, author, and so on.<p class="paragraph"/>Once you have a plugin distribution file you can navigate to a Grails project and type:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin /path/to/plugin/grails&#45;example&#45;0.1.zip</pre></div><p class="paragraph"/>If the plugin is hosted on a remote HTTP server you can also do:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin http://myserver.com/plugins/grails&#45;example&#45;0.1.zip</pre></div><p class="paragraph"/><h4>Notes on excluded Artefacts</h4><p class="paragraph"/>Although the <a href="../ref/Command Line/create-plugin.html" class="commandLine">create-plugin</a> command creates certain files for you so that the plug-in can be run as a Grails application, not all of these files are included when packaging a plug-in. The following is a list of artefacts created, but not included by <a href="../ref/Command Line/package-plugin.html" class="commandLine">package-plugin</a>:
<ul class="star">
<li><code>grails-app/conf/DataSource.groovy</code></li>
<li><code>grails-app/conf/UrlMappings.groovy</code></li>
<li><code>build.xml</code></li>
<li>Everything within <code>/web-app/WEB-INF</code></li>
</ul><p class="paragraph"/>If you need artefacts within <code>WEB-INF</code> it is recommended you use the <code>_Install.groovy</code> script (covered later), which is executed when a plug-in is installed, to provide such artefacts. In addition, although <code>UrlMappings.groovy</code> is excluded you are allowed to include a <code>UrlMappings</code> definition with a different name, such as <code>FooUrlMappings.groovy</code>.<p class="paragraph"/><h4>Specifying Plugin Locations</h4><p class="paragraph"/>An application can load plugins from anywhere on the file system, even if they have not been installed. Simply add the location of the (unpacked) plugin to the application's <code>grails-app/conf/BuildConfig.groovy</code> file:<p class="paragraph"/><div class="code"><pre>// Useful to test plugins you are developing.
grails.plugin.location.jsecurity = <span class="java&#45;quote">"/home/dilbert/dev/plugins/grails&#45;jsecurity"</span><p class="paragraph"/>// Useful <span class="java&#45;keyword">for</span> modular applications where all plugins and
// applications are in the same directory.
grails.plugin.location.'grails&#45;ui' = <span class="java&#45;quote">"../grails&#45;grails&#45;ui"</span></pre></div><p class="paragraph"/>This is particularly useful in two cases:
<ul class="star">
<li>You are developing a plugin and want to test it in a real application without packaging and installing it first.</li>
<li>You have split an application into a set of plugins and an application, all in the same "super-project" directory.</li>
</ul><p class="paragraph"/><h4>Global plugins</h4><p class="paragraph"/>Plugins can also be installed globally for all applications for a particular version of Grails using the <code>&#45;global</code> flag, for example:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin webtest &#45;global</pre></div><p class="paragraph"/>The default location is &#36;USER_HOME/.grails/&#60;grailsVersion&#62;/global-plugins but this can be customized with the <code>grails.global.plugins.dir</code> setting in <code>BuildConfig.groovy</code>.
<h2><a name="12.2 Plugin Repositories">12.2 Plugin Repositories</a></h2><h4>Distributing Plugins in the Grails Central Plugins Repository</h4><p class="paragraph"/>The preferred way of plugin distribution is to publish your under Grails Plugins Repository. This will make your plugin visible to the <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a> command:<p class="paragraph"/><div class="code"><pre>grails list&#45;plugins</pre></div><p class="paragraph"/>Which lists all plugins in the Grails Plugin repository and also the <a href="../ref/Command Line/plugin-info.html" class="commandLine">plugin-info</a> command:<p class="paragraph"/><div class="code"><pre>grails plugin&#45;info &#91;plugin&#45;name&#93;</pre></div><p class="paragraph"/>Which outputs more information based on the meta info entered into the plug-in descriptor.<p class="paragraph"/><blockquote class="note">
If you have created a Grails plugin and want it to be hosted in the central repository take a look at the wiki page <a href="http://grails.org/Creating+Plugins" target="blank"></a>, which details how to go about releasing your plugin in the repository.
</blockquote><p class="paragraph"/>When you have access to the Grails Plugin repository to release your plugin you simply have to execute the <a href="../ref/Command Line/release-plugin.html" class="commandLine">release-plugin</a> command:<p class="paragraph"/><div class="code"><pre>grails release&#45;plugin</pre></div><p class="paragraph"/>This will automatically commit changes to SVN, do some tagging and make your changes available via the <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a> command.<p class="paragraph"/><h4>Configuring Additional Repositories</h4><p class="paragraph"/>The way in which you configure repositories in Grails differs between Grails versions. For version of Grails 1.2 and earlier please refer to the <a href="http://grails.org/doc/1.2.x/guide/12.%20Plug-ins.html#12.2%20Plugin%20Repositories" target="blank">Grails 1.2 documentation</a> on the subject. The following sections cover Grails 1.3 and above.<p class="paragraph"/>Grails 1.3 and above use Ivy under the hood to resolve plugin dependencies. The mechanism for defining additional plugin repositories is largely the same as <a href="../guide/single.html#3.7 Dependency Resolution" class="guide">defining repositories for JAR dependencies</a>. For example you can define a remote Maven repository that contains Grails plugins using the following syntax in <code>grails-app/conf/BuildConfig.groovy</code>:<p class="paragraph"/><div class="code"><pre>repositories &#123;
	mavenRepo <span class="java&#45;quote">"http://repository.codehaus.org"</span>
&#125;</pre></div><p class="paragraph"/>You can also define a SVN-based Grails repository (such as the one hosted at http://plugins.grails.org/) using the <code>grailsRepo</code> method:<p class="paragraph"/><div class="code"><pre>repositories &#123;
	grailsRepo <span class="java&#45;quote">"http://myserver/mygrailsrepo"</span>
&#125;</pre></div><p class="paragraph"/>There is a shortcut to setup the Grails central repository:<p class="paragraph"/><div class="code"><pre>repositories &#123;
	grailsCentral()
&#125;</pre></div><p class="paragraph"/>The order in which plugins are resolved is based on the ordering of the repositories. So for example in this case the Grails central repository will be searched last:<p class="paragraph"/><div class="code"><pre>repositories &#123;
	grailsRepo <span class="java&#45;quote">"http://myserver/mygrailsrepo"</span>
	grailsCentral()
&#125;</pre></div><p class="paragraph"/>All of the above examples use HTTP, however you can specify any <a href="http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html" target="blank">Ivy resolver</a> to resolve plugins with. Below is an example that uses an SSH resolver:<p class="paragraph"/><div class="code"><pre>def sshResolver = <span class="java&#45;keyword">new</span> SshResolver(user:<span class="java&#45;quote">"myuser"</span>, host:<span class="java&#45;quote">"myhost.com"</span>)
sshResolver.addArtifactPattern(<span class="java&#45;quote">"/path/to/repo/grails&#45;&#91;artifact&#93;/tags/LATEST_RELEASE/grails&#45;&#91;artifact&#93;&#45;&#91;revision&#93;.&#91;ext&#93;"</span>)
sshResolver.latestStrategy = <span class="java&#45;keyword">new</span> org.apache.ivy.plugins.latest.LatestTimeStrategy()
sshResolver.changingPattern = <span class="java&#45;quote">".&#42;SNAPSHOT"</span>
sshResolver.setCheckmodified(<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>The above example defines an artifact pattern which tells Ivy how to resolve a plugin zip file. For a more detailed explanation on Ivy patterns see the <a href="http://ant.apache.org/ivy/history/2.1.0/concept.html#patterns" target="blank">relevant section</a> in the Ivy user guide.<p class="paragraph"/><h4>Publishing to Maven Compatible Repositories</h4><p class="paragraph"/>In general it is recommended for Grails 1.3 and above to use standard Maven-style repositories to self host plugins. The benefits of doing so include the ability for existing tooling and repository managers to interpret the structure of a Maven repository. In addition Maven compatible repositories are not tied to SVN as Grails repositories are.<p class="paragraph"/>In order to publish a plugin to a Maven repository you need to use the Maven publisher plugin. Please refer to the section of the guide:mavendeploy user guide on the subject.<p class="paragraph"/><h4>Publishing to Grails Compatible Repositories</h4><p class="paragraph"/>To publish a Grails plugin to a Grails compatible repository you specify the <code>grails.plugin.repos.distribution.myRepository</code> setting within the grails-app/conf/BuildConfig.groovy file:<p class="paragraph"/><div class="code"><pre>grails.plugin.repos.distribution.myRepository=<span class="java&#45;quote">"https://svn.codehaus.org/grails/trunk/grails&#45;test&#45;plugin&#45;repo"</span></pre></div><p class="paragraph"/>You can also provide this settings in the USER_HOME/.grails/settings.groovy file if you prefer to share the same settings across multiple projects.<p class="paragraph"/>Once this is done you need to use the <code>repository</code> argument of the <code>release-plugin</code> command to specify the repository you want to release the plugin into:<p class="paragraph"/><div class="code"><pre>grails release&#45;plugin &#45;repository=myRepository</pre></div><p class="paragraph"/><p class="paragraph"/><h2><a name="12.3 Understanding a Plug-ins Structure">12.3 Understanding a Plug-ins Structure</a></h2>As as mentioned previously, a plugin is merely a regular Grails application with a contained plug-in descriptors. However when installed, the structure of a plugin differs slightly. For example, take a look at this plugin directory structure:<p class="paragraph"/><div class="code"><pre>+ grails&#45;app
     + controllers
     + domain
     + taglib
     etc.
 + lib
 + src
     + java
     + groovy
 + web&#45;app
     + js
     + css</pre></div><p class="paragraph"/>Essentially when a plugin is installed into a project, the contents of the <code>grails-app</code> directory will go into a directory such as <code>plugins/example-1.0/grails-app</code>. They <strong class="bold">will not</strong> be copied into the main source tree. A plugin never interferes with a project's primary source tree.<p class="paragraph"/>Dealing with static resources is slightly different. When developing a plugin, just like an application, all static resources can go in the <code>web-app</code> directory. You can then link to static resources just like in an application (example below links to a javascript source):<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:resource dir=<span class="xml&#45;quote">"js"</span> file=<span class="xml&#45;quote">"mycode.js"</span> /&#62;</span></pre></div><p class="paragraph"/>When you run the plugin in development mode the link to the resource will resolve to something like <code>/js/mycode.js</code>. However, when the plugin is installed into an application the path will automatically change to something like <code>/plugin/example-0.1/js/mycode.js</code> and Grails will deal with making sure the resources are in the right place.<p class="paragraph"/>There is a special <code>pluginContextPath</code> variable that can be used whilst both developing the plugin and when in the plugin is installed into the application to find out what the correct path to the plugin is.<p class="paragraph"/>At runtime the <code>pluginContextPath</code> variable will either evaluate to an empty string or <code>/plugins/example</code> depending on whether the plugin is running standalone or has been installed in an application<p class="paragraph"/>Java &#38; Groovy code that the plugin provides within the lib and <code>src/java</code> and <code>src/groovy</code> directories will be compiled into the main project's <code>web-app/WEB-INF/classes</code> directory so that they are made available at runtime.
<h2><a name="12.4 Providing Basic Artefacts">12.4 Providing Basic Artefacts</a></h2><h4>Adding a new Script</h4><p class="paragraph"/>A plugin can add a new script simply by providing the relevant Gant script within the scripts directory of the plugin:<p class="paragraph"/><div class="code"><pre>+ MyPlugin.groovy
   + scripts     &#60;&#45;&#45; additional scripts here
   + grails&#45;app
        + controllers
        + services
        + etc.
    + lib</pre></div><p class="paragraph"/><h4>Adding a new Controller, Tag Library or Service</h4><p class="paragraph"/>A plugin can add a new controller, tag libraries, service or whatever by simply creating the relevant file within the <code>grails-app</code> tree. Note that when the plugin is installed it will be loaded from where it is installed and not copied into the main application tree.<p class="paragraph"/><div class="code"><pre>+ ExamplePlugin.groovy
   + scripts
   + grails&#45;app
        + controllers  &#60;&#45;&#45; additional controllers here
        + services &#60;&#45;&#45; additional services here
        + etc.  &#60;&#45;&#45; additional XXX here
    + lib</pre></div><p class="paragraph"/><h4>Providing Views, Templates and View resolution</h4><p class="paragraph"/>When a plugin provides a controller it may also provide default views to be rendered. This is an excellent way to modularize your application through plugins. The way it works is that Grails' view resolution mechanism will first look for the view in the application it is installed into and if that fails will attempt to look for the view within the plugin. In other words, you can override views provided by a plugin by creating corresponding GSPs in the application's <code>grails-app/views</code> directory.<p class="paragraph"/>For example, consider a controller called <code>BookController</code> that's provided by an 'amazon' plugin. If the action being executed is <code>list</code>, Grails will first look for a view called <code>grails-app/views/book/list.gsp</code> then if that fails it will look for the same view relative to the plugin.<p class="paragraph"/>Note however that if the view uses templates that are also provided by the plugin then the following syntax may be necessary:<p class="paragraph"/><div class="code"><pre>&#60;g:render template=<span class="java&#45;quote">"fooTemplate"</span> plugin=<span class="java&#45;quote">"amazon"</span>/&#62;</pre></div><p class="paragraph"/>Note the usage of the <code>plugin</code> attribute, which contains the name of the plugin where the template resides. If this is not specified then Grails will look for the template relative to the application.<p class="paragraph"/><h4>Excluded Artefacts</h4><p class="paragraph"/>Note that by default, Grails will exclude the following files from packaged plugins during the packaging process:
<ul class="star">
<li>grails-app/conf/DataSource.groovy</li>
<li>grails-app/conf/UrlMappings.groovy</li>
<li>Everything under web-app/WEB-INF</li>
</ul><p class="paragraph"/>If your plugin does require files under the <code>web-app/WEB-INF</code> directory it is recommended that you modify the plugin's <code>scripts/_Install.groovy</code> Gant script to install these artefacts into the target project's directory tree.<p class="paragraph"/>In addition, the default <code>UrlMappings.groovy</code> file is excluded to avoid naming conflicts, however you are free to add a UrlMappings definition under a different name which <strong class="bold">will</strong> be included. For example a file called <code>grails-app/conf/BlogUrlMappings.groovy</code> is fine.<p class="paragraph"/>Additionally the list of includes is extensible via the <code>pluginExcludes</code> property:<p class="paragraph"/><div class="code"><pre>// resources that are excluded from plugin packaging
def pluginExcludes = &#91;
        <span class="java&#45;quote">"grails&#45;app/views/error.gsp"</span>
&#93;</pre></div><p class="paragraph"/>This is useful, for example, if you want to include demo or test resources in the plugin repository, but not include them in the final distribution.<p class="paragraph"/>
<h2><a name="12.5 Evaluating Conventions">12.5 Evaluating Conventions</a></h2>Before moving onto looking at providing runtime configuration based on conventions you first need to understand how to evaluated those conventions from a plug-in. Essentially every plugin has an implicit <code>application</code> variable which is an instance of the <a href="../api/org/codehaus/groovy/grails/commons/GrailsApplication.html" class="api">GrailsApplication</a> interface.<p class="paragraph"/>The <code>GrailsApplication</code> interface provides methods to evaluate the conventions within the project and internally stores references to all classes within a GrailsApplication using the <a href="../api/org/codehaus/groovy/grails/commons/GrailsClass.html" class="api">GrailsClass</a> interface.<p class="paragraph"/>A <code>GrailsClass</code> represents a physical Grails resources such as a controller or a tag library. For example to get all <code>GrailsClass</code> instances you can do:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">for</span> (grailsClass in application.allClasses) &#123;
    println grailsClass.name
&#125;</pre></div><p class="paragraph"/>There are a few "magic" properties that the <code>GrailsApplication</code> instance possesses that allow you to narrow the type of artefact you are interested in. For example if you only want to controllers you can do:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">for</span> (controllerClass in application.controllerClasses) &#123;
    println controllerClass.name
&#125;</pre></div><p class="paragraph"/>The dynamic method conventions are as follows:
<ul class="star">
<li><code>*Classes</code> - Retrieves all the classes for a particular artefact name. Example <code>application.controllerClasses</code>.</li>
<li><code>get*Class</code> - Retrieves a named class for a particular artefact. Example <code>application.getControllerClass("ExampleController")</code></li>
<li><code>is*Class</code> - Returns true if the given class is of the given artefact type. Example <code>application.isControllerClass(ExampleController.class)</code></li>
</ul><p class="paragraph"/>The <code>GrailsClass</code> interface itself provides a number of useful methods that allow you to further evaluate and work with the conventions. These include:
<ul class="star">
<li><code>getPropertyValue</code> - Gets the initial value of the given property on the class</li>
<li><code>hasProperty</code> - Returns true if the class has the specified property</li>
<li><code>newInstance</code> - Creates a new instance of this class.</li>
<li><code>getName</code> -  Returns the logical name of the class in the application without the trailing convention part if applicable</li>
<li><code>getShortName</code> - Returns the short name of the class without package prefix</li>
<li><code>getFullName</code> - Returns the full name of the class in the application with the trailing convention part and with the package name</li>
<li><code>getPropertyName</code> - Returns the name of the class as a property name</li>
<li><code>getLogicalPropertyName</code> - Returns the logical property name of the class in the application without the trailing convention part if applicable</li>
<li><code>getNaturalName</code> - Returns the name of the property in natural terms (eg. 'lastName' becomes 'Last Name')</li>
<li><code>getPackageName</code> - Returns the package name</li>
</ul><p class="paragraph"/>For a full reference refer to the <a href="../api/org/codehaus/groovy/grails/commons/GrailsClass.html" class="api">javadoc API</a>.
<h2><a name="12.6 Hooking into Build Events">12.6 Hooking into Build Events</a></h2><h4>Post-Install Configuration and Participating in Upgrades</h4><p class="paragraph"/>Grails plug-ins can do post-install configuration and participate in application upgrade process (the <a href="../ref/Command Line/upgrade.html" class="commandLine">upgrade</a> command). This is achieved via two specially named scripts under <code>scripts</code> directory of the plugin - <code>_Install.groovy</code> and <code>_Upgrade.groovy</code>.<p class="paragraph"/><code>_Install.groovy</code> is executed after the plugin has been installed and <code>_Upgrade.groovy</code> is executed each time the user upgrades his application with <a href="../ref/Command Line/upgrade.html" class="commandLine">upgrade</a> command.<p class="paragraph"/>These scripts are normal <a href="../guide/single.html#4. The Command Line" class="guide">Gant</a> scripts so you can use the full power of Gant. An addition to the standard Gant variables is the <code>pluginBasedir</code> variable which points at the plugin installation basedir.<p class="paragraph"/>As an example the below <code>_Install.groovy</code>  script will create a new directory type under the <code>grails-app</code> directory and install a configuration template:<p class="paragraph"/><div class="code"><pre>Ant.mkdir(dir:<span class="java&#45;quote">"$&#123;basedir&#125;/grails&#45;app/jobs"</span>)
Ant.copy(file:<span class="java&#45;quote">"$&#123;pluginBasedir&#125;/src/samples/SamplePluginConfiguration.groovy"</span>,
         todir:<span class="java&#45;quote">"$&#123;basedir&#125;/grails&#45;app/conf"</span>)<p class="paragraph"/>// To access Grails home you can use following code:
// Ant.property(environment:<span class="java&#45;quote">"env"</span>)
// grailsHome = Ant.antProject.properties.<span class="java&#45;quote">"env.GRAILS_HOME"</span></pre></div><p class="paragraph"/>
<h4>Scripting events</h4><p class="paragraph"/>It is also possible to hook into command line scripting events through plug-ins. These are events triggered during execution of Grails target and plugin scripts.<p class="paragraph"/>For example, you can hook into status update output (i.e. "Tests passed", "Server running") and the creation of files or artefacts.<p class="paragraph"/>A plug-in merely has to provide an <code>_Events.groovy</code> script to listen to the required events. Refer the documentation on <a href="../guide/single.html#4.3 Hooking into Events" class="guide">Hooking into Events</a> for further information.<h2><a name="12.7 Hooking into Runtime Configuration">12.7 Hooking into Runtime Configuration</a></h2>Grails provides a number of hooks to leverage the different parts of the system and perform runtime configuration by convention.<p class="paragraph"/><h4>Hooking into the Grails Spring configuration</h4><p class="paragraph"/>First, you can hook in Grails runtime configuration by providing a property called <code>doWithSpring</code> which is assigned a block of code. For example the following snippet is from one of the core Grails plugins that provides <a href="../guide/single.html#10. Internationalization" class="guide">i18n</a> support:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.web.servlet.i18n.CookieLocaleResolver;
<span class="java&#45;keyword">import</span> org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
<span class="java&#45;keyword">import</span> org.springframework.context.support.ReloadableResourceBundleMessageSource;<p class="paragraph"/>class I18nGrailsPlugin &#123;<p class="paragraph"/>	def version = 0.1<p class="paragraph"/>	def doWithSpring = &#123;
		messageSource(ReloadableResourceBundleMessageSource) &#123;
			basename = <span class="java&#45;quote">"WEB&#45;INF/grails&#45;app/i18n/messages"</span>
		&#125;
		localeChangeInterceptor(LocaleChangeInterceptor) &#123;
			paramName = <span class="java&#45;quote">"lang"</span>
		&#125;
		localeResolver(CookieLocaleResolver)
	&#125;
&#125;</pre></div><p class="paragraph"/>This plugin sets up the Grails <code>messageSource</code> bean and a couple of other beans to manage Locale resolution and switching. It using the <a href="../guide/single.html#14. Grails and Spring" class="guide">Spring Bean Builder</a> syntax to do so.<p class="paragraph"/><h4>Participating in web.xml Generation</h4><p class="paragraph"/>Grails generates the <code>WEB-INF/web.xml</code> file at load time, and although plugins cannot change this file directly, they can participate in the generation of the file. Essentially a plugin can provide a <code>doWithWebDescriptor</code> property that is assigned a block of code that gets passed the <code>web.xml</code> as a <code>XmlSlurper</code> <code>GPathResult</code>.<p class="paragraph"/><h5>Add <code>servlet</code> and <code>servlet-mapping</code></h5><p class="paragraph"/>Consider the below example from the <code>ControllersPlugin</code>:<p class="paragraph"/><div class="code"><pre>def doWithWebDescriptor = &#123; webXml &#45;&#62;
	def mappingElement = webXml.'servlet&#45;mapping'
	def lastMapping = mappingElement&#91;mappingElement.size()&#45;1&#93;
	lastMapping + &#123;
		'servlet&#45;mapping' &#123;
			'servlet&#45;name'(<span class="java&#45;quote">"grails"</span>)
			'url&#45;pattern'(<span class="java&#45;quote">"&#42;.dispatch"</span>)
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>Here the plugin goes through gets a reference to the last <code>&#60;servlet-mapping&#62;</code> element and appends Grails' servlet to the end of it using XmlSlurper's ability to programmatically modify XML using closures and blocks.<p class="paragraph"/>
<h5>Add <code>filter</code> and <code>filter-mapping</code></h5><p class="paragraph"/>Adding a filter with its mapping works a little differently. The location of the <code>&#60;filter&#62;</code> element doesn't matter since order is not important, so it's simplest to insert your custom filter definition immediately after the last <code>&#60;context-param&#62;</code> element. Order  <em class="italic">is</em>  important for mappings, but the usual approach is to add it immediately after the last <code>&#60;filter&#62;</code> element like so:<p class="paragraph"/><div class="code"><pre>def doWithWebDescriptor = &#123; webXml &#45;&#62;
    def contextParam = webXml.'context&#45;param'
    contextParam&#91;contextParam.size() &#45; 1&#93; + &#123;
        'filter' &#123;
            'filter&#45;name'('springSecurityFilterChain')
            'filter&#45;class'(DelegatingFilterProxy.name)
        &#125;
    &#125;<p class="paragraph"/>    def filter = webXml.'filter'
    filter&#91;filter.size() &#45; 1&#93; + &#123;
        'filter&#45;mapping'&#123;
            'filter&#45;name'('springSecurityFilterChain')
            'url&#45;pattern'('/&#42;')
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>In some cases you will need to ensure that your filter comes after one of the standard Grails ones, such as the Spring character encoding filter or the SiteMesh filter. Fortunately, you can insert filter mappings immediately after the standard ones (more accurately, any that are in the template web.xml file) like so:<p class="paragraph"/><div class="code"><pre>def doWithWebDescriptor = &#123; webXml &#45;&#62;
    ...<p class="paragraph"/>    // Insert the Spring Security filter after the Spring
    // character encoding filter.
    def filter = webXml.'filter&#45;mapping'.find &#123;
        it.'filter&#45;name'.text() == <span class="java&#45;quote">"charEncodingFilter"</span>
    &#125;<p class="paragraph"/>    filter + &#123;
        'filter&#45;mapping'&#123;
            'filter&#45;name'('springSecurityFilterChain')
            'url&#45;pattern'('/&#42;')
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/><h4>Doing Post Initialisation Configuration</h4><p class="paragraph"/>Sometimes it is useful to be able do some runtime configuration after the Spring <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a> has been built. In this case you can define a <code>doWithApplicationContext</code> closure property.<p class="paragraph"/><div class="code"><pre>class SimplePlugin &#123;
     def name=<span class="java&#45;quote">"simple"</span>
     def version = 1.1<p class="paragraph"/>	 def doWithApplicationContext = &#123; appCtx &#45;&#62;
          SessionFactory sf = appCtx.getBean(<span class="java&#45;quote">"sessionFactory"</span>)
          // <span class="java&#45;keyword">do</span> something here with session factory
	 &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="12.8 Adding Dynamic Methods at Runtime">12.8 Adding Dynamic Methods at Runtime</a></h2><h4>The Basics</h4><p class="paragraph"/>Grails plugins allow you to register dynamic methods with any Grails managed or other class at runtime. New methods can only be added within a <code>doWithDynamicMethods</code> closure of a plugin.<p class="paragraph"/>For Grails managed classes like controllers, tag libraries and so forth you can add methods, constructors etc. using the <a href="http://groovy.codehaus.org/ExpandoMetaClass" target="blank">ExpandoMetaClass</a> mechanism by accessing each controller's <a href="api:http://groovy.codehaus.org/api/groovy/lang/MetaObjectProtocol.html" target="blank">MetaClass</a>:<p class="paragraph"/><div class="code"><pre>class ExamplePlugin &#123;
  def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
        application.controllerClasses.each &#123; controllerClass &#45;&#62;
             controllerClass.metaClass.myNewMethod = &#123;&#45;&#62; println <span class="java&#45;quote">"hello world"</span> &#125;
        &#125;
  &#125;
&#125;</pre></div><p class="paragraph"/>In this case we use the implicit application object to get a reference to all of the controller classes' MetaClass instances and then add a new method called <code>myNewMethod</code> to each controller.
Alternatively, if you know before hand the class you wish the add a method to you can simple reference that classes <code>metaClass</code> property:<p class="paragraph"/><div class="code"><pre>class ExamplePlugin &#123;<p class="paragraph"/>  def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
      <span class="java&#45;object">String</span>.metaClass.swapCase = &#123;&#45;&#62;
           def sb = <span class="java&#45;keyword">new</span> <span class="java&#45;object">StringBuffer</span>()
           delegate.each &#123;
               sb &#60;&#60; (<span class="java&#45;object">Character</span>.isUpperCase(it as <span class="java&#45;object">char</span>) ? 
                      <span class="java&#45;object">Character</span>.toLowerCase(it as <span class="java&#45;object">char</span>) : 
                      <span class="java&#45;object">Character</span>.toUpperCase(it as <span class="java&#45;object">char</span>))
           &#125;
           sb.toString()
      &#125;<p class="paragraph"/>      assert <span class="java&#45;quote">"UpAndDown"</span> == <span class="java&#45;quote">"uPaNDdOWN"</span>.swapCase()       
  &#125;
&#125;</pre></div><p class="paragraph"/>In this example we add a new method <code>swapCase</code> to <code>java.lang.String</code> directly by accessing its <code>metaClass</code>.<p class="paragraph"/><h4>Interacting with the ApplicationContext</h4><p class="paragraph"/>The <code>doWithDynamicMethods</code> closure gets passed the Spring <code>ApplicationContext</code> instance. This is useful as it allows you to interact with objects within it. For example if you where implementing a method to interact with Hibernate you could use the <code>SessionFactory</code> instance in combination with a <code>HibernateTemplate</code>:<p class="paragraph"/>
<div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.orm.hibernate3.HibernateTemplate<p class="paragraph"/>class ExampleHibernatePlugin &#123;<p class="paragraph"/>   def doWithDynamicMethods = &#123; applicationContext &#45;&#62;<p class="paragraph"/>       application.domainClasses.each &#123; domainClass &#45;&#62;<p class="paragraph"/>           domainClass.metaClass.<span class="java&#45;keyword">static</span>.load = &#123; <span class="java&#45;object">Long</span> id&#45;&#62; 
                def sf = applicationContext.sessionFactory
                def template = <span class="java&#45;keyword">new</span> HibernateTemplate(sf)
				template.load(delegate, id)
           &#125;
       &#125;
   &#125;
&#125;</pre></div><p class="paragraph"/>Also because of the autowiring and dependency injection capability of the Spring container you can implement more powerful dynamic constructors that use the application context to wire dependencies into your object at runtime:<p class="paragraph"/><div class="code"><pre>class MyConstructorPlugin &#123;<p class="paragraph"/>    def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
         application.domainClasses.each &#123; domainClass &#45;&#62;
              domainClass.metaClass.constructor = &#123;&#45;&#62;
                  <span class="java&#45;keyword">return</span> applicationContext.getBean(domainClass.name)
              &#125;
         &#125;<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/>Here we actually replace the default constructor with one that looks up prototyped Spring beans instead!<p class="paragraph"/><h2><a name="12.9 Participating in Auto Reload Events">12.9 Participating in Auto Reload Events</a></h2><h4>Monitoring Resources for Changes</h4><p class="paragraph"/>Often it is valuable to monitor resources for changes and then reload those changes when they occur. This is how Grails implements advanced reloading of application state at runtime. For example, consider the below simplified snippet from the <code>ServicesPlugin</code> that Grails comes with:<p class="paragraph"/><div class="code"><pre>class ServicesGrailsPlugin &#123;
    &#8230;
    def watchedResources = <span class="java&#45;quote">"file:./grails&#45;app/services/&#42;Service.groovy"</span><p class="paragraph"/>    &#8230;
    def onChange = &#123; event &#45;&#62;
        <span class="java&#45;keyword">if</span>(event.source) &#123;
            def serviceClass = application.addServiceClass(event.source)
            def serviceName = <span class="java&#45;quote">"$&#123;serviceClass.propertyName&#125;"</span>
            def beans = beans &#123;
                <span class="java&#45;quote">"$serviceName"</span>(serviceClass.getClazz()) &#123; bean &#45;&#62;
                    bean.autowire =  <span class="java&#45;keyword">true</span>
                &#125;
            &#125;
            <span class="java&#45;keyword">if</span>(event.ctx) &#123;
                event.ctx.registerBeanDefinition(serviceName,
                                                 beans.getBeanDefinition(serviceName))
            &#125;
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>Firstly it defines a set of <code>watchedResources</code> as either a String or a List of strings that contain either the references or patterns of the resources to watch. If the watched resources is a Groovy file, when it is changed it will automatically be reloaded and passed into the <code>onChange</code> closure inside the <code>event</code> object.<p class="paragraph"/>The <code>event</code> object defines a number of useful properties:
<ul class="star">
<li><code>event.source</code> - The source of the event which is either the reloaded class or a Spring Resource</li>
<li><code>event.ctx</code> - The Spring <code>ApplicationContext</code> instance</li>
<li><code>event.plugin</code> - The plugin object that manages the resource (Usually this)</li>
<li><code>event.application</code> - The <code>GrailsApplication</code> instance</li>
</ul><p class="paragraph"/>From these objects you can evaluate the conventions and then apply the appropriate changes to the <code>ApplicationContext</code> and so forth based on the conventions, etc.  In the "Services" example above, a new services bean is re-registered with the <code>ApplicationContext</code> when one of the service classes changes.<p class="paragraph"/><h4>Influencing Other Plugins</h4><p class="paragraph"/>As well as being able to react to changes that occur when a plugin changes, sometimes one plugin needs to "influence" another plugin.<p class="paragraph"/>Take for example the Services &#38; Controllers plugins. When a service is reloaded, unless you reload the controllers too, problems will occur when you try to auto-wire the reloaded service into an older controller Class.<p class="paragraph"/>To get round this, you can specify which plugins another plugin "influences". What this means is that when one plugin detects a change, it will reload itself and then reload all influenced plugins. See this snippet from the <code>ServicesGrailsPlugin</code>:<p class="paragraph"/><div class="code"><pre>def influences = &#91;'controllers'&#93;</pre></div><p class="paragraph"/><h4>Observing other plugins</h4><p class="paragraph"/>If there is a particular plugin that you would like to observe for changes but not necessary watch the resources that it monitors you can use the "observe" property:<p class="paragraph"/><div class="code"><pre>def observe = &#91;<span class="java&#45;quote">"controllers"</span>&#93;</pre></div><p class="paragraph"/>In this case when a controller is changed you will also receive the event chained from the controllers plugin. It is also possible for a plugin to observe all loaded plugins by using a wildcard:<p class="paragraph"/><div class="code"><pre>def observe = &#91;<span class="java&#45;quote">"&#42;"</span>&#93;</pre></div><p class="paragraph"/>The Logging plugin does exactly this so that it can add the <code>log</code> property back to  <em class="italic">any</em>  artefact that changes while the application is running.<h2><a name="12.10 Understanding Plug-in Load Order">12.10 Understanding Plug-in Load Order</a></h2><h4>Controlling Plug-in Dependencies</h4><p class="paragraph"/>Plug-ins often depend on the presence of other plugins and can also adapt depending on the presence of others. To cover this, a plugin can define two properties. The first is called <code>dependsOn</code>. For example, take a look at this snippet from the Grails Hibernate plugin:<p class="paragraph"/><div class="code"><pre>class HibernateGrailsPlugin &#123;
	def version = 1.0
	def dependsOn = &#91;dataSource:1.0,
	                 domainClass:1.0,
	                 i18n:1.0,
	                 core: 1.0&#93;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>As the above example demonstrates the Hibernate plugin is dependent on the presence of 4 plugins: The <code>dataSource</code> plugin, The <code>domainClass</code> plugin, the <code>i18n</code> plugin and the <code>core</code> plugin.<p class="paragraph"/>Essentially the dependencies will be loaded first and then the Hibernate plugin. If all dependencies do not load, then the plugin will not load.<p class="paragraph"/>The <code>dependsOn</code> property also supports a mini expression language for specifying version ranges. A few examples of the syntax can be seen below:<p class="paragraph"/><div class="code"><pre>def dependsOn = &#91;foo:<span class="java&#45;quote">"&#42; &#62; 1.0"</span>&#93;
def dependsOn = &#91;foo:<span class="java&#45;quote">"1.0 &#62; 1.1"</span>&#93;
def dependsOn = &#91;foo:<span class="java&#45;quote">"1.0 &#62; &#42;"</span>&#93;</pre></div><p class="paragraph"/>When the wildcard * character is used it denotes "any" version. The expression syntax also excludes any suffixes such as -BETA, -ALPHA etc. so for example the expression "1.0 &#62; 1.1" would match any of the following versions:
<ul class="star">
<li>1.1</li>
<li>1.0</li>
<li>1.0.1</li>
<li>1.0.3-SNAPSHOT</li>
<li>1.1-BETA2</li>
</ul><p class="paragraph"/><h4>Controlling Load Order </h4><p class="paragraph"/>Using <code>dependsOn</code> establishes a "hard" dependency in that if the dependency is not resolved, the plugin will give up and won't load.  It is possible though to have a "weaker" dependency using the <code>loadAfter</code> property:<p class="paragraph"/><div class="code"><pre>def loadAfter = &#91;'controllers'&#93;</pre></div><p class="paragraph"/>Here the plugin will be loaded after the <code>controllers</code> plugin if it exists, otherwise it will just be loaded. The plugin can then adapt to the presence of the other plugin, for example the Hibernate plugin has this code in the <code>doWithSpring</code> closure:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">if</span>(manager?.hasGrailsPlugin(<span class="java&#45;quote">"controllers"</span>)) &#123;
	openSessionInViewInterceptor(OpenSessionInViewInterceptor) &#123;
        	flushMode = HibernateAccessor.FLUSH_MANUAL
	        sessionFactory = sessionFactory
	&#125;
        grailsUrlHandlerMapping.interceptors &#60;&#60; openSessionInViewInterceptor
  &#125;</pre></div><p class="paragraph"/>Here the Hibernate plugin will only register an <code>OpenSessionInViewInterceptor</code> if the <code>controllers</code> plugin has been loaded. The manager variable is an instance of the <a href="../api/org/codehaus/groovy/grails/plugins/GrailsPluginManager.html" class="api">GrailsPluginManager</a> interface and it provides methods to interact with other plugins and the <code>GrailsPluginManager</code> itself from any plugin.
        </div>
    </body>
</html>
