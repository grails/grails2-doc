<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
        <title>5.3.4 Eager and Lazy Fetching</title>
        <link rel="stylesheet" href="../../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
        <link rel="icon" href="../../img/favicon.ico" type="image/x-icon"/>
        <link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon"/>
    </head>
    <body class="body">
        <div id="header">
            <h2><a name="5.3.4 Eager and Lazy Fetching">5.3.4 Eager and Lazy Fetching</a></h2>
        </div>
        <div id="toc">
            
        </div>
        <div id="content">
            Associations in GORM are by default lazy. This is best explained by example:<p class="paragraph"/><div class="code"><pre>class Airport &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
&#125;
class Flight &#123;
    <span class="java&#45;object">String</span> number
    Location destination
    <span class="java&#45;keyword">static</span> belongsTo = &#91;airport:Airport&#93;
&#125;
class Location &#123;
    <span class="java&#45;object">String</span> city
    <span class="java&#45;object">String</span> country
&#125;</pre></div><p class="paragraph"/>Given the above domain classes and the following code:<p class="paragraph"/><div class="code"><pre>def airport = Airport.findByName(<span class="java&#45;quote">"Gatwick"</span>)
airport.flights.each &#123;
    println it.destination.city
&#125;</pre></div><p class="paragraph"/>GORM will execute a single SQL query to fetch the <code>Airport</code> instance, another to get its flights, and then 1 extra query for <em class="italic">each iteration</em> over the <code>flights</code> association to get the current flight's destination. In other words you get N+1 queries (if you exclude the original one to get the airport).<p class="paragraph"/><h3>Configuring Eager Fetching</h3><p class="paragraph"/>An alternative approach that avoids the N+1 queries is to use eager fetching, which can be specified as follows:<p class="paragraph"/><div class="code"><pre>class Airport &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        flights lazy: <span class="java&#45;keyword">false</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>In this case the <code>flights</code> association will be loaded at the same time as its <code>Airport</code> instance, although a second query will be executed to fetch the collection. You can also use <code>fetch: 'join'</code> instead of <code>lazy: false</code> , in which case GORM will only execute a single query to get the airports and their flights. This works well for single-ended associations, but you need to be careful with one-to-manys. Queries will work as you'd expect right up to the moment you add a limit to the number of results you want. At that point, you will likely end up with fewer results than you were expecting. The reason for this is quite technical but ultimately the problem arises from GORM using a left outer join.<p class="paragraph"/>So, the recommendation is currently to use <code>fetch: 'join'</code> for single-ended associations and <code>lazy: false</code> for one-to-manys.<p class="paragraph"/>Be careful how and where you use eager loading because you could load your entire database into memory with too many eager associations. You can find more information on the mapping options in the <a href="../guide/single.html#5.5.2.8 Eager and Lazy Fetching" class="guide">section on the ORM DSL</a>.<p class="paragraph"/><h3>Using Batch Fetching</h3><p class="paragraph"/>Although eager fetching is appropriate for some cases, it is not always desirable. If you made everything eager you could quite possibly load your entire database into memory resulting in performance and memory problems. An alternative to eager fetching is to use batch fetching. Essentially, you can configure Hibernate to lazily fetch results in "batches". For example:<p class="paragraph"/><div class="code"><pre>class Airport &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        flights batchSize:10
    &#125;
&#125;</pre></div><p class="paragraph"/>In this case, due to the <code>batchSize</code> argument, when you iterate over the <code>flights</code> association, Hibernate will fetch results in batches of 10. For example if you had an <code>Airport</code> that had 30 flights, if you didn't configure batch fetching you would get 1 query to fetch the <code>Airport</code> and then <code>30</code> queries to fetch each flight. With batch fetching you get 1 query to fetch the <code>Airport</code> and 3 queries to fetch each <code>Flight</code> in batches of 10. In other words, batch fetching is an optimization of the lazy fetching strategy. Batch fetching can also be configured at the class level as follows:<p class="paragraph"/><div class="code"><pre>class Flight &#123;
    &#8230;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        batchSize 10
    &#125;
&#125;</pre></div><p class="paragraph"/>Check out <a href="http://blog.springsource.com/2010/07/28/gorm-gotchas-part-3/" target="blank">part 3</a> of the GORM Gotchas series for more in-depth coverage of this tricky topic.

        </div>
    </body>
</html>
